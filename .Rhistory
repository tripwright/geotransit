#  GTFS_filter <- GTFS_filter %>%
#  mutate(urls = ifelse(is.na(urls.latest), URL, urls.latest))
# Iterate through each URL and download GTFS files
for (i in seq_len(nrow(GTFS_filter))) {
url <- GTFS_filter$url_latest[i]  # Adjust the column name as necessary
file <- GTFS_filter$id[i]  # Adjust the column name as necessary
filename <- paste0(file, ".zip")  # Create filename based on provider column
# Attempt to download without API key initially
response <- GET(url, timeout(60))
# Check for Unauthorized status
if (http_status(response)$category == "Client error" && http_status(response)$reason == "Unauthorized") {
# Prompt user for API key
message(paste("Unauthorized access for:", filename))
api_key <- readline(prompt = "Enter API key for this URL: ")
# Retry the download with the provided API key (as query parameter)
response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# Option code to add support for sending API key in the header if required by some URLs
# Uncomment the following block to send the API key in the header instead:
#
# send_in_header <- readline(prompt = "Send API key in header? (yes/no): ")
# if (tolower(send_in_header) == "yes") {
#   response <- GET(url, add_headers(Authorization = paste("Bearer", api_key)), timeout(60))
# } else {
#   response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# }
}
# Handle response and download file
tryCatch({
if (http_status(response)$category == "Success") {
filepath <- file.path(output_dir, filename)
writeBin(content(response, "raw"), filepath)
message(paste("Downloaded:", filename))
} else {
warning(paste("Failed to download:", filename, "with status:", http_status(response)$reason))
}
}, error = function(e) {
warning(paste("Failed to download after retries:", conditionMessage(e)))
})
}
}
# Load the GTFS dataframe
load(system.file("data/GTFS_df.rda", package = "geotransit"))
list.files(path = system.file("data", package = "geotransit"))
file_path <- system.file("data/GTFS_df.rda", package = "geotransit")
print(file_path)
devtools::document()  # Update documentation
devtools::install()   # Install the package locally
usethis::use_data()
rlang::last_trace()
list.files(path = "data")
usethis::use_data(GTFS_df, overwrite = TRUE)
library(geotransit)  # Load package
rm(list = c("sf2gtfs"))  # Remove the conflicting function from the Global Environment
detach("package:geotransit", unload = TRUE)
library(geotransit)
load("~/Documents/Academic/4. Senior Year/Research/geotransit/data/GTFS_df.rda")
load("~/Documents/Academic/4. Senior Year/Research/geotransit/data/GTFS_df.rda")
View(GTFS_df)
file_path <- system.file("data/GTFS_df.rda", package = "geotransit")
print(file_path)  # Should return the path to the .rda file
# Make sure the file exists in the data folder after running use_data()
list.files(path = "data")
devtools::document()   # Update the documentation if needed
devtools::install()    # Reinstall the package
# Manually load the .rda file
load(system.file("data/GTFS_df.rda", package = "geotransit"))
# This checks the data folder in the installed package
list.files(path = system.file("data", package = "geotransit"))
# Manually load the .rda file
load(system.file("data/GTFS_df.rda", package = "geotransit"))
devtools::load_all()  # Loads the package in the current session
# Check if the data is loaded correctly
head(GTFS_df)  # Should show the contents of the data
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
list.files(path = system.file("data", package = "geotransit"))
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS, overwrite = TRUE)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
list.files(path = system.file("data", package = "geotransit"))
# This checks the data folder in the installed package
list.files(path = system.file("data", package = "geotransit"))
file_path <- system.file("data/GTFS_df.rda", package = "geotransit")
print(file_path)  # Should return the path to the .rda file
fs::path_package("data", package = "idonotexist")
fs::path_package("data", package = "geotransit")
fs::path_package("GTFS", package = "geotransit")
readxl::readxl_example()
fs::path_package("data", "GFTS.rda", package = "geotransit")
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS, overwrite = TRUE)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
# Load the GTFS dataframe
head(GTFS_df)
# Load the GTFS dataframe
data("GTFS_df", package = "geotransit")
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit")
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit")
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
View(GTFS_df)
usethis::use_data(GTFS_df, overwrite = TRUE)
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit")
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit")
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit")
library(tidyverse)
library(sf)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("data-raw/csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
devtools::document()
devtools::clean_dll()  # Clean the package installation
devtools::install()    # Reinstall the package
GTFS_filter <- GTFS_df %>%
filter(sapply(geometry, function(g) any(st_intersects(g, bbox_sf, sparse = FALSE))))
install.packages("remotes")
