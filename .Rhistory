# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out NA, sf2GTFS only downloads static GTFS files
GTFS_df <- GTFS_df %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt")
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df <- GTFS_df %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326))), # Ensure the same CRS
id = paste0(provider, ifelse(is.na(name), "", name)))
# Check for invalid geometries and fix
GTFS_df <- GTFS_df %>%
mutate(geometry = st_make_valid(geometry))
usethis::use_data(GTFS_df, overwrite = TRUE)
sf2GTFS <- function(shapefile, output_dir) {
# Load the GTFS dataframe
load(system.file("data/GTFS_df.rda", package = "geotransit"))
# Create the directory if it doesn't exist
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)  # Recursive = TRUE creates parent directories if necessary
}
# Create bounding box from the urban area
bbox <- st_bbox(shapefile)
bbox_sf <- st_as_sfc(bbox) %>%
st_set_crs(st_crs(shapefile)) %>%
st_transform(crs = 4326)
# Filter routes whose bounding boxes intersect with the urban area bounding box
GTFS_filter <- GTFS_df %>%
filter(st_intersects(geometry, bbox_sf, sparse = FALSE))
# New column for URL. If 'urls.latest' is NA, replaces with values from 'URL'
#  GTFS_filter <- GTFS_filter %>%
#  mutate(urls = ifelse(is.na(urls.latest), URL, urls.latest))
# Iterate through each URL and download GTFS files
for (i in seq_len(nrow(GTFS_filter))) {
url <- GTFS_filter$urls[i]  # Adjust the column name as necessary
file <- GTFS_filter$id[i]  # Adjust the column name as necessary
filename <- paste0(file, ".zip")  # Create filename based on provider column
# Attempt to download without API key initially
response <- GET(url, timeout(60))
# Check for Unauthorized status
if (http_status(response)$category == "Client error" && http_status(response)$reason == "Unauthorized") {
# Prompt user for API key
message(paste("Unauthorized access for:", filename))
api_key <- readline(prompt = "Enter API key for this URL: ")
# Retry the download with the provided API key (as query parameter)
response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# Option code to add support for sending API key in the header if required by some URLs
# Uncomment the following block to send the API key in the header instead:
#
# send_in_header <- readline(prompt = "Send API key in header? (yes/no): ")
# if (tolower(send_in_header) == "yes") {
#   response <- GET(url, add_headers(Authorization = paste("Bearer", api_key)), timeout(60))
# } else {
#   response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# }
}
# Handle response and download file
tryCatch({
if (http_status(response)$category == "Success") {
filepath <- file.path(output_dir, filename)
writeBin(content(response, "raw"), filepath)
message(paste("Downloaded:", filename))
} else {
warning(paste("Failed to download:", filename, "with status:", http_status(response)$reason))
}
}, error = function(e) {
warning(paste("Failed to download after retries:", conditionMessage(e)))
})
}
}
setwd("~/Documents/Academic/4. Senior Year/Research")
sf2GTFS(DC_UrbanMap,"GTFS_test2")
sf2GTFS <- function(shapefile, output_dir) {
# Load the GTFS dataframe
load(system.file("data/GTFS_df.rda", package = "geotransit"))
# Create the directory if it doesn't exist
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)  # Recursive = TRUE creates parent directories if necessary
}
# Create bounding box from the urban area
bbox <- st_bbox(shapefile)
bbox_sf <- st_as_sfc(bbox) %>%
st_set_crs(st_crs(shapefile)) %>%
st_transform(crs = 4326)
# Filter routes whose bounding boxes intersect with the urban area bounding box
GTFS_filter <- GTFS_df %>%
filter(st_intersects(geometry, bbox_sf, sparse = FALSE))
# New column for URL. If 'urls.latest' is NA, replaces with values from 'URL'
#  GTFS_filter <- GTFS_filter %>%
#  mutate(urls = ifelse(is.na(urls.latest), URL, urls.latest))
# Iterate through each URL and download GTFS files
for (i in seq_len(nrow(GTFS_filter))) {
url <- GTFS_filter$urls.latest[i]  # Adjust the column name as necessary
file <- GTFS_filter$id[i]  # Adjust the column name as necessary
filename <- paste0(file, ".zip")  # Create filename based on provider column
# Attempt to download without API key initially
response <- GET(url, timeout(60))
# Check for Unauthorized status
if (http_status(response)$category == "Client error" && http_status(response)$reason == "Unauthorized") {
# Prompt user for API key
message(paste("Unauthorized access for:", filename))
api_key <- readline(prompt = "Enter API key for this URL: ")
# Retry the download with the provided API key (as query parameter)
response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# Option code to add support for sending API key in the header if required by some URLs
# Uncomment the following block to send the API key in the header instead:
#
# send_in_header <- readline(prompt = "Send API key in header? (yes/no): ")
# if (tolower(send_in_header) == "yes") {
#   response <- GET(url, add_headers(Authorization = paste("Bearer", api_key)), timeout(60))
# } else {
#   response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# }
}
# Handle response and download file
tryCatch({
if (http_status(response)$category == "Success") {
filepath <- file.path(output_dir, filename)
writeBin(content(response, "raw"), filepath)
message(paste("Downloaded:", filename))
} else {
warning(paste("Failed to download:", filename, "with status:", http_status(response)$reason))
}
}, error = function(e) {
warning(paste("Failed to download after retries:", conditionMessage(e)))
})
}
}
sf2GTFS(DC_UrbanMap,"GTFS_test2")
View(GTFS_df)
GTFS_df <- GTFS_df %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, URL, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min,
lon_max, status, geometry) %>%
rename(country = location.country_code)
View(GTFS_df)
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df <- GTFS_df %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326))), # Ensure the same CRS
id = paste0(provider, ifelse(is.na(name), "", " "name)))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df <- GTFS_df %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326))), # Ensure the same CRS
id = paste(provider, ifelse(is.na(name), "", name), sep = ifelse(is.na(name), "", " ")))
# Check for invalid geometries and fix
GTFS_df <- GTFS_df %>%
mutate(geometry = st_make_valid(geometry))
View(GTFS_df)
GTFS_df <- GTFS_df %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, URL, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min,
lon_max, status, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, )
View(GTFS_df)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out NA, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt")
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit/data-raw")
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
View(GTFS_df)
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out NA, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = paste(provider, ifelse(is.na(name), "", name), sep = ifelse(is.na(name), "", " ")))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features)
View(GTFS_df)
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features)
View(GTFS_df)
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
usethis::use_data(GTFS_df, overwrite = TRUE)
setwd("~/Documents/Academic/4. Senior Year/Research")
#' Download static GTFS files from a shapefile
#'
#' This function downloads static GTFS files for all transit routes operating within a specified shapefile and saves them to directory.
#'
#' @param shapefile A shapefile to download GTFS files from a specified geography.
#' @param output_dir A character string specifying the directory to save the downloaded files.
#'
#' @return NULL
#' @export
sf2GTFS <- function(shapefile, output_dir) {
# Load the GTFS dataframe
load(system.file("data/GTFS_df.rda", package = "geotransit"))
# Create the directory if it doesn't exist
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)  # Recursive = TRUE creates parent directories if necessary
}
# Create bounding box from the urban area
bbox <- st_bbox(shapefile)
bbox_sf <- st_as_sfc(bbox) %>%
st_set_crs(st_crs(shapefile)) %>%
st_transform(crs = 4326)
# Filter routes whose bounding boxes intersect with the urban area bounding box
GTFS_filter <- GTFS_df %>%
filter(st_intersects(geometry, bbox_sf, sparse = FALSE))
# New column for URL. If 'urls.latest' is NA, replaces with values from 'URL'
#  GTFS_filter <- GTFS_filter %>%
#  mutate(urls = ifelse(is.na(urls.latest), URL, urls.latest))
# Iterate through each URL and download GTFS files
for (i in seq_len(nrow(GTFS_filter))) {
url <- GTFS_filter$url_latest[i]  # Adjust the column name as necessary
file <- GTFS_filter$id[i]  # Adjust the column name as necessary
filename <- paste0(file, ".zip")  # Create filename based on provider column
# Attempt to download without API key initially
response <- GET(url, timeout(60))
# Check for Unauthorized status
if (http_status(response)$category == "Client error" && http_status(response)$reason == "Unauthorized") {
# Prompt user for API key
message(paste("Unauthorized access for:", filename))
api_key <- readline(prompt = "Enter API key for this URL: ")
# Retry the download with the provided API key (as query parameter)
response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# Option code to add support for sending API key in the header if required by some URLs
# Uncomment the following block to send the API key in the header instead:
#
# send_in_header <- readline(prompt = "Send API key in header? (yes/no): ")
# if (tolower(send_in_header) == "yes") {
#   response <- GET(url, add_headers(Authorization = paste("Bearer", api_key)), timeout(60))
# } else {
#   response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# }
}
# Handle response and download file
tryCatch({
if (http_status(response)$category == "Success") {
filepath <- file.path(output_dir, filename)
writeBin(content(response, "raw"), filepath)
message(paste("Downloaded:", filename))
} else {
warning(paste("Failed to download:", filename, "with status:", http_status(response)$reason))
}
}, error = function(e) {
warning(paste("Failed to download after retries:", conditionMessage(e)))
})
}
}
sf2GTFS(DC_UrbanMap, "GTFS_test1")
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = paste(provider, ifelse(is.na(name), "", name), sep = ifelse(is.na(name), "", " ")))
setwd("~/Documents/Academic/4. Senior Year/Research/geotransit/data-raw")
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = paste(provider, ifelse(is.na(name), "", name), sep = ifelse(is.na(name), "", " ")))
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
View(GTFS_df)
View(GTFS_df1)
# Read the CSV file "GTFS_df.csv" into a data frame named GTFS_df
GTFS_df <- read_csv("csv/GTFS_df.csv")
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = paste(provider, name, sep = ifelse(is.na(name), "", " ")))
View(GTFS_df1)
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = paste(provider, ifelse(is.na(name), "", paste0(" ", name))))
View(GTFS_df1)
# Rename bounding box coord columns to simpler names
# Filter the data frame keep rows where lon_min, lon_max, lat_min, and lat_max have values
# Filtering out realtime GTFS, sf2GTFS only downloads static GTFS files
GTFS_df1 <- GTFS_df %>%
rename(lat_min = location.bounding_box.minimum_latitude,
lat_max = location.bounding_box.maximum_latitude,
lon_min = location.bounding_box.minimum_longitude,
lon_max = location.bounding_box.maximum_longitude) %>%
filter(!is.na(lon_min) & !is.na(lon_max) & !is.na(lat_min) & !is.na(lat_max)) %>%
filter(data_type != "gtfs-rt") %>%
# Create unique id column by combining provider with name (when applicable)
mutate(id = ifelse(is.na(name), provider, paste(provider, name)))
View(GTFS_df1)
# Prepare GTFS bounding boxes and convert them to sf objects
# Assuming your GTFS_df has lat_min, lat_max, lon_min, lon_max columns for the bounding boxes
GTFS_df2 <- GTFS_df1 %>%
rowwise() %>%
mutate(geometry = st_as_sfc(st_bbox(c(
xmin = lon_min,
ymin = lat_min,
xmax = lon_max,
ymax = lat_max), crs = st_crs(4326)))) # Ensure the same CRS
# Check for invalid geometries and fix
GTFS_df3 <- GTFS_df2 %>%
mutate(geometry = st_make_valid(geometry))
GTFS_df <- GTFS_df3 %>%
select(location.country_code, location.subdivision_name, location.municipality,
provider, name, id, feed_contact_email, urls.direct_download, urls.latest,
urls.authentication_info, urls.license, lat_min, lat_max, lon_min, lon_max,
status, features, geometry) %>%
rename(country = location.country_code, region = location.subdivision_name,
city = location.municipality, provider = provider, name = name, id = id,
contact = feed_contact_email, url_source = urls.direct_download,
url_latest = urls.latest, url_authenticate = urls.authentication_info,
license = urls.license, lat_min = lat_min, lat_max = lat_max, lon_min = lon_min,
lon_max = lon_max, status = status, features = features, geometry = geometry)
View(GTFS_df)
usethis::use_data(GTFS_df, overwrite = TRUE)
setwd("~/Documents/Academic/4. Senior Year/Research")
#' Download static GTFS files from a shapefile
#'
#' This function downloads static GTFS files for all transit routes operating within a specified shapefile and saves them to directory.
#'
#' @param shapefile A shapefile to download GTFS files from a specified geography.
#' @param output_dir A character string specifying the directory to save the downloaded files.
#'
#' @return NULL
#' @export
sf2GTFS <- function(shapefile, output_dir) {
# Load the GTFS dataframe
load(system.file("data/GTFS_df.rda", package = "geotransit"))
# Create the directory if it doesn't exist
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)  # Recursive = TRUE creates parent directories if necessary
}
# Create bounding box from the urban area
bbox <- st_bbox(shapefile)
bbox_sf <- st_as_sfc(bbox) %>%
st_set_crs(st_crs(shapefile)) %>%
st_transform(crs = 4326)
# Filter routes whose bounding boxes intersect with the urban area bounding box
GTFS_filter <- GTFS_df %>%
filter(st_intersects(geometry, bbox_sf, sparse = FALSE))
# New column for URL. If 'urls.latest' is NA, replaces with values from 'URL'
#  GTFS_filter <- GTFS_filter %>%
#  mutate(urls = ifelse(is.na(urls.latest), URL, urls.latest))
# Iterate through each URL and download GTFS files
for (i in seq_len(nrow(GTFS_filter))) {
url <- GTFS_filter$url_latest[i]  # Adjust the column name as necessary
file <- GTFS_filter$id[i]  # Adjust the column name as necessary
filename <- paste0(file, ".zip")  # Create filename based on provider column
# Attempt to download without API key initially
response <- GET(url, timeout(60))
# Check for Unauthorized status
if (http_status(response)$category == "Client error" && http_status(response)$reason == "Unauthorized") {
# Prompt user for API key
message(paste("Unauthorized access for:", filename))
api_key <- readline(prompt = "Enter API key for this URL: ")
# Retry the download with the provided API key (as query parameter)
response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# Option code to add support for sending API key in the header if required by some URLs
# Uncomment the following block to send the API key in the header instead:
#
# send_in_header <- readline(prompt = "Send API key in header? (yes/no): ")
# if (tolower(send_in_header) == "yes") {
#   response <- GET(url, add_headers(Authorization = paste("Bearer", api_key)), timeout(60))
# } else {
#   response <- GET(modify_url(url, query = list(api_key = api_key)), timeout(60))
# }
}
# Handle response and download file
tryCatch({
if (http_status(response)$category == "Success") {
filepath <- file.path(output_dir, filename)
writeBin(content(response, "raw"), filepath)
message(paste("Downloaded:", filename))
} else {
warning(paste("Failed to download:", filename, "with status:", http_status(response)$reason))
}
}, error = function(e) {
warning(paste("Failed to download after retries:", conditionMessage(e)))
})
}
}
sf2GTFS(DC_UrbanMap, "GTFS_test2")
?sf
class(DC_UrbanMap)
View(DC_UrbanMap)
?st_bbox
st_as_sfc()
?st_as_sfc
